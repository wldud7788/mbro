<?php
require_once dirname(__FILE__) . '/../libraries/Definitions.php';

/**
 * Scan file.
 *
 * @param $info
 *
 * @return array
 */
function scanFile($filePath)
{
	$patternFound = [];

	$deobfuscator = new Deobfuscator();
	$contentRaw = file_get_contents($filePath);
	$contentClean = CodeMatch::stripWhitespace($contentRaw);

	$contentDeobfuscated = $deobfuscator->deobfuscate($contentClean);
	$contentDecoded = $deobfuscator->decode($contentDeobfuscated);

	$contents = [
		'raw' => $contentRaw, // Original content
		'cleaned' => $contentClean, // Cleaned content
		'deobfuscated' => $contentDeobfuscated, // Deobfuscated content
		'decoded' => $contentDecoded, // Decoded content
	];

	/**
	 * Scan exploits.
	 */
	foreach (Definitions::$EXPLOITS as $key => $exploit) {
		$lastMatch = null;
		$pattern = $exploit['pattern'];
		$checkExploit = function ($match) use ($contentRaw, $exploit, $pattern, $key, &$patternFound) {
			$type = 'exploit';
			$lastMatch = $match[0];
			$patternFoundKey = $type . $key;
			$lineNumber = CodeMatch::getLineNumber($lastMatch, $contentRaw);
			if ($lineNumber !== null) {
				$patternFoundKey .= $lineNumber;
			}
			if (!empty($lastMatch)) {
				$patternFound[$patternFoundKey] = [
					'type' => $type,
					'key' => $key,
					'level' => $exploit['level'],
					'output' => CodeMatch::getText($type, $key, $exploit['description'], $lastMatch, $lineNumber),
					'description' => $exploit['description'],
					'line' => $lineNumber,
					'pattern' => $pattern,
					'match' => $lastMatch,
				];
				if (isset($exploit['link'])) {
					$patternFound[$patternFoundKey]['link'] = $exploit['link'];
				}
			}
		};
		// Check exploits
		foreach ($contents as $content) {
			if (@preg_match_all($pattern, $content, $matches, PREG_OFFSET_CAPTURE)) {
				foreach ($matches[0] as $match) {
					$checkExploit($match);
					if (count($patternFound) > 0) return $patternFound;
				}
			}
		}
	}

	/**
	 * Scan definitions.
	 */
	foreach (Signatures::getAll() as $key => $pattern) {
		$lastMatch = null;
		$regexPattern = '#' . $pattern . '#smiS';
		$checkDefinitions = function ($match) use ($contentRaw, $key, $regexPattern, &$patternFound) {
			$type = 'sign';
			$key = hash('crc32b', $key);
			$lastMatch = $match[0];
			$patternFoundKey = $type . $key;
			$lineNumber = CodeMatch::getLineNumber($lastMatch, $contentRaw);
			if ($lineNumber !== null) {
				$patternFoundKey .= $lineNumber;
			}
			if (!empty($lastMatch)) {
				$descriptionPrefix = 'Signature';
				$description = 'Malware Signature (hash: ' . $key . ')';
				$patternFound[$patternFoundKey] = [
					'type' => $type,
					'key' => $key,
					'level' => CodeMatch::DANGEROUS,
					'output' => CodeMatch::getText($descriptionPrefix, $key, $description, $lastMatch, $lineNumber),
					'description' => $description,
					'line' => $lineNumber,
					'pattern' => $regexPattern,
					'match' => $lastMatch,
				];
			}
		};
		// Check definitions
		foreach ($contents as $content) {
			if (@preg_match_all($regexPattern, $content, $matches, PREG_OFFSET_CAPTURE)) {
				foreach ($matches[0] as $match) {
					$checkDefinitions($match);
					if (count($patternFound) > 0) return $patternFound;
				}
			}
		}
	}

	// Comments are no needed to check function usage so remove raw content type
	unset($contents['raw']);
	foreach (Functions::$dangerous as $funcRaw) {
		$lastMatch = null;
		$func = preg_quote(trim($funcRaw), '/');
		$checkFunction = function (
			$match,
			$pattern,
			$level = CodeMatch::WARNING,
			$descriptionPrefix = '',
			$functionType = ''
		) use ($contentRaw, $funcRaw, &$patternFound) {
			$type = 'function';
			$suffix = '';
			if (!empty($functionType)) {
				$suffix = '_' . $functionType;
			}
			$lastMatch = CodeMatch::cleanFunctionResult($match[0]); // Clean match
			$funcKey = $funcRaw . $suffix;
			$patternFoundKey = $type . $funcKey;
			$lineNumber = CodeMatch::getLineNumber($lastMatch, $contentRaw);
			if ($lineNumber !== null) {
				$patternFoundKey .= $lineNumber;
			}
			if (!empty($lastMatch) && empty($patternFound[$patternFoundKey])) {
				$description = $descriptionPrefix . ' `' . $funcRaw . '`';
				$patternFound[$patternFoundKey] = [
					'type' => trim($type . ' ' . $functionType),
					'key' => $funcKey,
					'level' => $level,
					'output' => CodeMatch::getText($type, $funcRaw, $description, $lastMatch, $lineNumber),
					'description' => $description,
					'line' => $lineNumber,
					'pattern' => $pattern,
					'match' => $lastMatch,
					'link' => 'https://www.php.net/' . $funcRaw,
				];
			}
		};

		/**
		 * Functions.
		 */
		if (in_array($funcRaw, Functions::$dangerous, true)) {

			$regexPattern = CodeMatch::patternFunction($func);
			foreach ($contents as $contentType => $content) {
				$codeParts = CodeMatch::getTemplateCode($content);
				foreach ($codeParts as $codePart) {
					/**
					 * Raw functions.
					 */
					if (@preg_match_all($regexPattern, $codePart[0], $matches, PREG_OFFSET_CAPTURE)) {

						foreach ($matches[0] as $match) {
							$descriptionPrefix = 'Potentially dangerous function';
							$severity = CodeMatch::WARNING;
							if ($contentType === 'decoded') {
								$severity = CodeMatch::DANGEROUS;
								$descriptionPrefix = 'Encoded Function';
							}
							$checkFunction(
								$match,
								$regexPattern,
								$severity,
								$descriptionPrefix
							);
							if (count($patternFound) > 0) return $patternFound;
						}
					}
				}
			}
		}
	}

	// Remove duplicated without line number
	return $patternFound;
}